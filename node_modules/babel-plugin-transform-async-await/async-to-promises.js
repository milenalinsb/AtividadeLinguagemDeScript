"use strict";
exports.__esModule = true;
var fs_1 = require("fs");
var path_1 = require("path");
;
var errorOnIncompatible = true;
;
var helpers;
var alwaysTruthy = ["Object", "Function", "Boolean", "Error", "String", "Number", "Math", "Date", "RegExp", "Array"];
var numberNames = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
function default_1(_a) {
    var types = _a.types, template = _a.template, traverse = _a.traverse, transformFromAst = _a.transformFromAst, version = _a.version;
    var isNewBabel = !/^6\./.test(version);
    function wrapNodeInStatement(node) {
        if (types.isStatement(node)) {
            return types.blockStatement([node]);
        }
        if (types.isExpression(node)) {
            return types.expressionStatement(node);
        }
        throw new Error("Expected either an expression or a statement, got a " + node.type + "!");
    }
    function pathForNewNode(node, parentPath) {
        var result = parentPath.context.create(parentPath.node, [node], 0, "dummy");
        result.setContext(parentPath.context);
        return result;
    }
    function pathsPassTest(matchingNodeTest, referenceOriginalNodes) {
        function visit(path, result, state) {
            if (referenceOriginalNodes) {
                var originalNode = path.node._originalNode;
                if (originalNode) {
                    traverse(wrapNodeInStatement(originalNode), visitor, path.scope, { match: result, state: state }, path);
                    return false;
                }
            }
            var doesMatch = matchingNodeTest(path);
            if (doesMatch) {
                result.any = true;
                result.all = !(state.breakingLabels.length || state.unnamedBreak);
                // result.paths.push(path);
            }
            if (path.isBreakStatement()) {
                var label = path.node.label;
                if (!label) {
                    state.unnamedBreak = true;
                }
                else if (state.breakingLabels.indexOf(label.name) === -1) {
                    state.breakingLabels.push(label.name);
                }
            }
            if (path.isLabeledStatement()) {
                var index = state.breakingLabels.indexOf(path.node.label.name);
                if (index !== -1) {
                    state.breakingLabels.splice(index, 1);
                }
            }
            if (path.isLoop()) {
                state.unnamedBreak = false;
            }
            if (doesMatch) {
                return false;
            }
            if (path.isConditional()) {
                var test = match(path.get("test"), state);
                var consequent = match(path.get("consequent"), state);
                var alternate = match(path.get("alternate"), state);
                result.any = result.any || test.any || consequent.any || alternate.any;
                // result.paths = result.paths.concat(test.paths).concat(consequent.paths).concat(alternate.paths);
                return (result.all = (test.all || (consequent.all && alternate.all)) && !(state.breakingLabels.length || state.unnamedBreak));
            }
            if (path.isSwitchStatement()) {
                var discriminant = match(path.get("discriminant"), state);
                var cases_1 = path.get("cases");
                var caseMatches = cases_1.map(function (switchCase, i) {
                    var newState = { unnamedBreak: false, breakingLabels: state.breakingLabels };
                    var newResult = match(switchCase, newState);
                    for (i++; (!newResult.all || pathsBreakReturnOrThrow(switchCase).all) && i < cases_1.length; i++) {
                        var tailMatch = match(cases_1[i], newState);
                        newResult.all = (newResult.all || tailMatch.all) && !(state.breakingLabels.length || state.unnamedBreak);
                        newResult.any = newResult.any || tailMatch.any;
                        // newResult.paths = newResult.paths.concat(tailMatch.paths);
                    }
                    return newResult;
                });
                result.any = result.any || discriminant.any || caseMatches.some(function (caseMatch) { return caseMatch.any; });
                // result.paths = caseMatches.reduce((acc, match) => acc.concat(match.paths), result.paths.concat(discriminant.paths));
                return result.all = ((discriminant.all || (cases_1.some(function (switchCase) { return !switchCase.node.test; }) && caseMatches.every(function (caseMatch) { return caseMatch.all; }))) && !(state.breakingLabels.length || state.unnamedBreak));
            }
            if (path.isDoWhileStatement()) {
                var body = match(path.get("body"), { unnamedBreak: false, breakingLabels: state.breakingLabels });
                var test = match(path.get("test"), state);
                result.any = result.any || body.any || test.any;
                // result.paths = result.paths.concat(test.paths).concat(body.paths);
                return result.all = ((body.all || test.all) && !(state.breakingLabels.length || state.unnamedBreak));
            }
            if (path.isWhileStatement()) {
                // TODO: Support detecting break/return statements
                var testPath = path.get("test");
                var test = match(testPath, state);
                var body = match(path.get("body"), { unnamedBreak: false, breakingLabels: state.breakingLabels });
                result.any = result.any || test.any || body.any;
                // result.paths = result.paths.concat(test.paths).concat(body.paths);
                return result.all = ((test.all || (body.all && (extractLooseBooleanValue(testPath.node) === true))) && !(state.breakingLabels.length || state.unnamedBreak));
            }
            if (path.isForXStatement()) {
                var right = match(path.get("right"), state);
                var body = match(path.get("body"), { unnamedBreak: false, breakingLabels: state.breakingLabels });
                result.any = result.any || right.any || body.any;
                // result.paths = result.paths.concat(right.paths).concat(body.paths);
                return result.all = (right.all && !(state.breakingLabels.length || state.unnamedBreak));
            }
            if (path.isForStatement()) {
                var init = match(path.get("init"), state);
                var test = match(path.get("test"), state);
                var body = match(path.get("body"), { unnamedBreak: false, breakingLabels: state.breakingLabels });
                var update = match(path.get("update"), state);
                result.any = result.any || init.any || test.any || body.any || update.any;
                // result.paths = result.paths.concat(init.paths).concat(test.paths).concat(update.paths).concat(body.paths);
                return result.all = ((init.all || test.all) && !(state.breakingLabels.length || state.unnamedBreak));
            }
            if (path.isLogicalExpression()) {
                var left = match(path.get("left"), state);
                var right = match(path.get("right"), state);
                result.any = result.any || left.any || right.any;
                // result.paths = result.paths.concat(left.paths).concat(right.paths);
                return result.all = (left.all && !(state.breakingLabels.length || state.unnamedBreak));
            }
            if (path.isReturnStatement()) {
                return true;
            }
            if (path.isBreakStatement()) {
                return true;
            }
            if (path.isContinueStatement()) {
                return true;
            }
            if (path.isThrowStatement()) {
                // TODO: Handle throw statements correctly
                return true;
            }
            if (path.isTryStatement()) {
                var blockMatch = match(path.get("block"), state);
                var finalizer = path.get("finalizer");
                var finalizerMatch = match(finalizer, state);
                var handler = path.get("handler");
                var handlerMatch = match(handler, state);
                result.any = result.any || blockMatch.any || handlerMatch.any || finalizerMatch.any;
                // result.paths = result.paths.concat(blockMatch.paths).concat(handlerMatch.paths).concat(finalizerMatch.paths);
                if (finalizerMatch.all) {
                    return result.all = !(state.breakingLabels.length || state.unnamedBreak);
                }
                else if (!finalizer.node) {
                    return result.all = (handlerMatch.all && blockMatch.all && !(state.breakingLabels.length || state.unnamedBreak));
                }
                return false;
            }
            if (path.isFunction()) {
                return false;
            }
        }
        var visitor = {
            enter: function (path) {
                switch (visit(path, this.match, this.state)) {
                    case true:
                        path.stop();
                        break;
                    case false:
                        path.skip();
                        break;
                }
            }
        };
        function match(path, state) {
            var match = { all: false, any: false };
            if (path && path.node) {
                if (typeof visit(path, match, state) === "undefined") {
                    path.traverse(visitor, { match: match, state: state });
                }
            }
            return match;
        }
        return function (path) { return match(path, { breakingLabels: [], unnamedBreak: false }); };
    }
    function pathsReachNodeTypes(matchingNodeTypes, referenceOriginalNodes) {
        return pathsPassTest(function (path) { return path.type !== null && matchingNodeTypes.indexOf(path.type) !== -1; }, referenceOriginalNodes);
    }
    var pathsReturnOrThrow = pathsReachNodeTypes(["ReturnStatement", "ThrowStatement"], true);
    var pathsReturnOrThrowCurrentNodes = pathsReachNodeTypes(["ReturnStatement", "ThrowStatement"], false);
    var pathsBreak = pathsReachNodeTypes(["BreakStatement"], true);
    var pathsBreakReturnOrThrow = pathsReachNodeTypes(["ReturnStatement", "ThrowStatement", "BreakStatement"], true);
    function isNonEmptyStatement(statement) {
        return !types.isEmptyStatement(statement);
    }
    function expressionInSingleReturnStatement(statements) {
        statements = statements.filter(isNonEmptyStatement);
        if (statements.length === 1) {
            var firstStatement = statements[0];
            if (types.isReturnStatement(firstStatement)) {
                var argument = firstStatement.argument;
                if (argument) {
                    return argument;
                }
            }
        }
    }
    function propertyNameOfMemberExpression(node) {
        var property = node.property;
        if (node.computed) {
            if (types.isStringLiteral(property)) {
                return property.value;
            }
        }
        else {
            if (types.isIdentifier(property)) {
                return property.name;
            }
        }
    }
    function identifiersInForToLengthStatement(statement) {
        // Match: for (var i = 0; i < array.length; i++)
        var init = statement.get("init");
        if (init.isVariableDeclaration() && init.node.declarations.length === 1) {
            var declaration = init.get("declarations")[0];
            if (types.isNumericLiteral(declaration.node.init) && declaration.node.init.value === 0) {
                var i = declaration.node.id;
                var test = statement.get("test");
                if (types.isIdentifier(i) &&
                    test.isBinaryExpression() &&
                    test.node.operator === "<" &&
                    types.isIdentifier(test.node.left) &&
                    test.node.left.name === i.name) {
                    var right = test.get("right");
                    if (right.isMemberExpression()) {
                        var object = right.node.object;
                        if (types.isIdentifier(object) &&
                            propertyNameOfMemberExpression(right.node) === "length") {
                            var update_1 = statement.get("update");
                            if (update_1.isUpdateExpression() &&
                                update_1.node.operator == "++" &&
                                types.isIdentifier(update_1.node.argument) &&
                                update_1.node.argument.name === i.name) {
                                var binding = statement.scope.getBinding(i.name);
                                if (binding) {
                                    var updateArgument_1 = update_1.get("argument");
                                    if (!binding.constantViolations.some(function (cv) { return cv !== updateArgument_1 && cv !== update_1; })) {
                                        return {
                                            i: i,
                                            array: object
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    function extractForOwnBodyPath(path) {
        // Match: for (var key of obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { ... } }
        var left = path.get("left");
        if (left.isVariableDeclaration()) {
            left = left.get("declarations")[0].get("id");
        }
        var right = path.get("right");
        // Check to see if we have a simple for of statement with two variables
        if (left.isIdentifier() && right.isIdentifier()) {
            var rightBinding = path.scope.getBinding(right.node.name);
            if (rightBinding && rightBinding.constant) {
                var body = path.get("body");
                for (;;) {
                    var statements = void 0;
                    if (body.isBlockStatement()) {
                        statements = body.get("body");
                    }
                    else if (body.isReturnStatement()) {
                        var argument = body.get("argument");
                        if (argument.isCallExpression() && invokeTypeOfExpression(argument) && argument.get("arguments").length === 1) {
                            var firstArgument = argument.get("arguments")[0];
                            if (firstArgument.isFunctionExpression()) {
                                statements = firstArgument.get("body").get("body");
                            }
                            else {
                                break;
                            }
                        }
                        else {
                            break;
                        }
                    }
                    else {
                        break;
                    }
                    if (statements.length !== 1) {
                        return;
                    }
                    body = statements[0];
                }
                // Check for an if statement with a single call expression
                if (body.isIfStatement() && !body.node.alternate) {
                    var test = body.get("test");
                    if (test.isCallExpression() && test.node.arguments.length === 2) {
                        var args = test.get("arguments");
                        // Check that call arguments match the key and target variables
                        var firstArg = args[0];
                        var secondArg = args[1];
                        if (firstArg.isIdentifier() && firstArg.node.name === right.node.name &&
                            secondArg.isIdentifier() && secondArg.node.name === left.node.name) {
                            // Check for .call(...)
                            var callee = test.get("callee");
                            if (callee.isMemberExpression() && propertyNameOfMemberExpression(callee.node) === "call") {
                                // Check for .hasOwnProperty
                                var method = callee.get("object");
                                if (method.isMemberExpression() && propertyNameOfMemberExpression(method.node) === "hasOwnProperty") {
                                    var target = method.get("object");
                                    // Check for empty temporary object
                                    if (target.isObjectExpression() && target.node.properties.length === 0) {
                                        return body.get("consequent");
                                    }
                                    // Strip .prototype if present
                                    if (target.isMemberExpression() && propertyNameOfMemberExpression(target.node) === "prototype") {
                                        target = target.get("object");
                                    }
                                    // Check for Object
                                    if (target.isIdentifier() && target.node.name === "Object") {
                                        return body.get("consequent");
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    function isPassthroughContinuation(continuation) {
        if (!continuation || !types.isFunctionExpression(continuation)) {
            return false;
        }
        if (continuation.params.length === 1) {
            var expression = expressionInSingleReturnStatement(continuation.body.body);
            if (expression) {
                var firstParam = continuation.params[0];
                if (types.isIdentifier(firstParam)) {
                    var valueName = firstParam.name;
                    if (types.isIdentifier(expression) && expression.name === valueName) {
                        return true;
                    }
                    if (types.isConditionalExpression(expression) && types.isIdentifier(expression.test) && types.isIdentifier(expression.consequent) && expression.consequent.name === valueName && types.isIdentifier(expression.alternate) && expression.alternate.name === valueName) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    function awaitAndContinue(state, path, value, continuation, directExpression) {
        if (continuation && isPassthroughContinuation(continuation)) {
            continuation = undefined;
        }
        if (!continuation && directExpression && extractLooseBooleanValue(directExpression) === true) {
            return value;
        }
        var useCallHelper;
        var args;
        if (types.isCallExpression(value) && value.arguments.length === 0 && !types.isMemberExpression(value.callee)) {
            useCallHelper = true;
            args = [value.callee];
        }
        else {
            useCallHelper = false;
            args = [value];
        }
        var ignoreResult = continuation && types.isIdentifier(continuation) && continuation === path.hub.file.declarations["_empty"];
        if (!ignoreResult && continuation) {
            args.push(unwrapReturnCallWithPassthroughArgument(continuation, path.scope));
        }
        if (directExpression && extractLooseBooleanValue(directExpression) !== false) {
            if (!ignoreResult && !continuation) {
                args.push(voidExpression());
            }
            args.push(directExpression);
        }
        var helperName = directExpression ? (useCallHelper ? "_call" : "_await") : (useCallHelper ? "_invoke" : "_continue");
        if (ignoreResult) {
            helperName += "Ignored";
        }
        if (args.length === 1) {
            switch (helperName) {
                case "_invoke":
                    return types.callExpression(args[0], []);
                case "_continue":
                    return args[0];
            }
        }
        return types.callExpression(helperReference(state, path, helperName), args);
    }
    function voidExpression(arg) {
        return types.unaryExpression("void", arg || types.numericLiteral(0));
    }
    function borrowTail(target) {
        var current = target;
        var dest = [];
        while (current && current.node && current.inList && current.container) {
            while (current.key + 1 < current.container.length) {
                dest.push(current.container[current.key + 1]);
                current.getSibling(current.key + 1).remove();
            }
            current = current.parentPath;
            if (!current.isBlockStatement()) {
                break;
            }
        }
        return dest;
    }
    function exitsInTail(target) {
        var current = target;
        while (current && current.node && current.inList && current.container && !current.isFunction()) {
            for (var i = current.key + 1; i < current.container.length; i++) {
                var sibling = current.container[current.key + 1];
                if (pathsReturnOrThrow(current).any) {
                    return true;
                }
            }
            current = current.parentPath;
        }
        return false;
    }
    function returnStatement(argument, originalNode) {
        var result = types.returnStatement(argument);
        result._skip = true;
        result._originalNode = originalNode;
        return result;
    }
    function removeUnnecessaryReturnStatements(blocks) {
        while (blocks.length) {
            var lastStatement = blocks[blocks.length - 1];
            if (types.isReturnStatement(lastStatement)) {
                if (lastStatement.argument === null || lastStatement.argument === undefined) {
                    blocks = blocks.slice(0, blocks.length - 1);
                }
                else {
                    if (blocks.length > 1) {
                        var previousStatement = blocks[blocks.length - 2];
                        if (types.isIfStatement(previousStatement) && !previousStatement.alternate) {
                            var consequent = previousStatement.consequent;
                            while (types.isBlockStatement(consequent)) {
                                if (consequent.body.length !== 1) {
                                    return blocks;
                                }
                                consequent = consequent.body[0];
                            }
                            if (types.isReturnStatement(consequent) && consequent.argument) {
                                blocks = blocks.slice(0, blocks.length - 2);
                                blocks.push(types.returnStatement(conditionalExpression(previousStatement.test, consequent.argument, lastStatement.argument)));
                            }
                        }
                    }
                    break;
                }
            }
            else {
                if (types.isIfStatement(lastStatement)) {
                    var consequent = lastStatement.consequent;
                    if (types.isBlockStatement(consequent)) {
                        consequent = blockStatement(removeUnnecessaryReturnStatements(consequent.body));
                    }
                    var alternate = lastStatement.alternate;
                    if (alternate) {
                        if (types.isBlockStatement(alternate)) {
                            var removedOfUnnecessary = removeUnnecessaryReturnStatements(alternate.body);
                            alternate = removedOfUnnecessary.length ? blockStatement(removedOfUnnecessary) : undefined;
                        }
                        else if (removeUnnecessaryReturnStatements([alternate]).length === 0) {
                            alternate = undefined;
                        }
                    }
                    if (consequent !== lastStatement.consequent || alternate !== lastStatement.alternate) {
                        blocks = blocks.slice(0, blocks.length - 1);
                        blocks.push(types.ifStatement(lastStatement.test, consequent, alternate || undefined));
                    }
                }
                break;
            }
        }
        return blocks;
    }
    function rewriteAsyncNode(state, parentPath, node, additionalConstantNames, exitIdentifier, unpromisify) {
        var path = pathForNewNode(node, parentPath);
        rewriteAsyncBlock(state, path, additionalConstantNames, exitIdentifier, unpromisify);
        return path.node;
    }
    function allScopes(scope) {
        var result = [];
        while (scope) {
            result.push(scope);
            scope = scope.parent;
        }
        return result;
    }
    var hoistCallArgumentsInnerVisitor = {
        Identifier: function (identifierPath) {
            if (identifierSearchesScope(identifierPath)) {
                var name = identifierPath.node.name;
                if (this.argumentNames.indexOf(name) === -1) {
                    if (this.additionalConstantNames.indexOf(name) !== -1) {
                        this.scopes.push(this.path.scope.parent);
                    }
                    else {
                        var binding = identifierPath.scope.getBinding(name);
                        if (binding) {
                            if (binding.scope && this.pathScopes.includes(binding.scope)) {
                                this.scopes.push(binding.scope);
                            }
                        }
                        else if (isNewBabel) {
                            // Babel 7 doesn't resolve bindings for some reason, need to be conservative with hoisting
                            this.scopes.push(this.path.scope.parent);
                        }
                    }
                }
            }
        }
    };
    function isValueLiteral(node) {
        return types.isStringLiteral(node) || types.isNumericLiteral(node) || types.isBooleanLiteral(node);
    }
    function keyFilter(key, value) {
        return key === "start" || key === "end" || key === "loc" ? null : value;
    }
    function nodesAreIdentical(node) {
        // Temporary deduping mechanism that filters source locations to see if nodes are otherwise identical
        var cached = JSON.stringify(node, keyFilter);
        return function (other) {
            return cached === JSON.stringify(other, keyFilter);
        };
    }
    var hoistCallArgumentsVisitor = {
        FunctionExpression: function (path) {
            path.skip();
            var bodyPath = path.get("body");
            if (bodyPath.node.body.length === 0) {
                path.replaceWith(helperReference(this.state, path, "_empty"));
                return;
            }
            var argumentNames = [];
            for (var _i = 0, _a = path.node.params; _i < _a.length; _i++) {
                var param = _a[_i];
                if (types.isIdentifier(param) || types.isPattern(param) || types.isRestElement(param)) {
                    addConstantNames(argumentNames, param);
                }
                else {
                    return;
                }
            }
            var scopes = [];
            var pathScopes = allScopes(path.scope.parent);
            bodyPath.traverse(hoistCallArgumentsInnerVisitor, {
                argumentNames: argumentNames,
                scopes: scopes,
                pathScopes: pathScopes,
                path: path,
                additionalConstantNames: this.additionalConstantNames
            });
            var scope = path.scope.getProgramParent();
            var ancestry = [scope];
            for (var _b = 0, scopes_1 = scopes; _b < scopes_1.length; _b++) {
                var otherScope = scopes_1[_b];
                if (!ancestry.includes(otherScope)) {
                    scope = otherScope;
                    ancestry = ancestry.concat(allScopes(otherScope));
                }
            }
            if (!ancestry.includes(path.scope.parent)) {
                var bindings = scope.bindings;
                var filter = void 0;
                for (var key in bindings) {
                    if (Object.hasOwnProperty.call(bindings, key)) {
                        var binding = bindings[key];
                        if (binding.constant) {
                            var bindingPath = binding.path;
                            if (bindingPath.isVariableDeclarator()) {
                                var init = bindingPath.get("init");
                                if (init.isFunctionExpression()) {
                                    if (!filter) {
                                        filter = nodesAreIdentical(path.node);
                                    }
                                    if (filter(init.node)) {
                                        path.replaceWith(binding.identifier);
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }
                var nameNode = path.node;
                if (types.isFunctionExpression(nameNode) && nameNode.body.body.length === 1) {
                    nameNode = nameNode.body.body[0];
                }
                if (types.isReturnStatement(nameNode) && nameNode.argument) {
                    nameNode = nameNode.argument;
                }
                if (types.isCallExpression(nameNode)) {
                    var callee = nameNode.callee;
                    if (types.isIdentifier(callee) && callee._helperName) {
                        nameNode = nameNode.arguments[0];
                    }
                }
                var identifier = isValueLiteral(nameNode) ? path.scope.generateUidIdentifier(nameNode.value.toString().replace(/\d/g, function (number) { return numberNames[number]; })) : path.scope.generateUidIdentifierBasedOnNode(nameNode, "temp");
                scope.push({ id: identifier, init: path.node });
                path.replaceWith(identifier);
            }
        }
    };
    function hoistCallArguments(state, path, additionalConstantNames) {
        if (path.isCallExpression()) {
            var callee = path.node.callee;
            if (types.isIdentifier(callee) && callee._helperName) {
                path.traverse(hoistCallArgumentsVisitor, { state: state, additionalConstantNames: additionalConstantNames });
            }
        }
    }
    function relocateTail(state, awaitExpression, statementNode, target, additionalConstantNames, temporary, exitCheck, directExpression) {
        var tail = borrowTail(target);
        var expression;
        var originalNode = target.node;
        var rewrittenTail = statementNode || tail.length ? rewriteAsyncNode(state, target, blockStatement((statementNode ? [statementNode] : []).concat(tail)), additionalConstantNames).body : [];
        var blocks = removeUnnecessaryReturnStatements(rewrittenTail.filter(isNonEmptyStatement));
        if (blocks.length) {
            if (exitCheck) {
                if (temporary && !types.isIdentifier(temporary)) {
                    var temporaryIdentifier = temporary = target.scope.generateUidIdentifier("temp");
                    var declaration = types.variableDeclaration("var", [types.variableDeclarator(temporary, temporaryIdentifier)]);
                    blocks = [declaration].concat(blocks);
                    temporary = temporaryIdentifier;
                }
                blocks = removeUnnecessaryReturnStatements([types.ifStatement(exitCheck, returnStatement(temporary))].concat(blocks));
            }
            var fn = types.functionExpression(undefined, temporary ? [temporary] : [], blockStatement(blocks));
            expression = awaitAndContinue(state, target, awaitExpression, fn, directExpression);
            originalNode = types.blockStatement([target.node].concat(tail));
        }
        else if (pathsReturnOrThrow(target).any) {
            expression = awaitAndContinue(state, target, awaitExpression, undefined, directExpression);
        }
        else {
            expression = awaitAndContinue(state, target, awaitExpression, helperReference(state, target, "_empty"), directExpression);
        }
        target.replaceWith(returnStatement(expression, originalNode));
        if (state.opts.hoist && target.isReturnStatement()) {
            var argument = target.get("argument");
            if (argument.node) {
                hoistCallArguments(state, argument, additionalConstantNames);
            }
        }
    }
    var rewriteThisVisitor = {
        Function: function (path) {
            if (!path.isArrowFunctionExpression()) {
                path.skip();
            }
        },
        ThisExpression: function (path) {
            if (!this.thisIdentifier) {
                this.thisIdentifier = path.scope.generateUidIdentifier("this");
            }
            path.replaceWith(this.thisIdentifier);
        }
    };
    function rewriteThisExpressions(rewritePath, targetPath) {
        var state = {};
        rewritePath.traverse(rewriteThisVisitor, state);
        if (state.thisIdentifier) {
            targetPath.scope.push({ id: state.thisIdentifier, init: types.thisExpression() });
        }
    }
    var rewriteThisArgumentsAndHoistVisitor = {
        Function: function (path) {
            path.skip();
            if (path.isArrowFunctionExpression()) {
                path.traverse(rewriteThisVisitor, this);
            }
        },
        ThisExpression: function (path) {
            if (!this.thisIdentifier) {
                this.thisIdentifier = path.scope.generateUidIdentifier("this");
            }
            path.replaceWith(this.thisIdentifier);
        },
        Identifier: function (path) {
            // Rewrite arguments
            if (path.node.name === "arguments") {
                if (!this.argumentsIdentifier) {
                    this.argumentsIdentifier = path.scope.generateUidIdentifier("arguments");
                }
                path.replaceWith(this.argumentsIdentifier);
            }
        },
        VariableDeclaration: function (path) {
            var scope = path.scope;
            if (path.node.kind === "var") {
                var declarations = path.get("declarations");
                for (var _i = 0, declarations_1 = declarations; _i < declarations_1.length; _i++) {
                    var declaration = declarations_1[_i];
                    var id = declaration.node.id;
                    if (types.isIdentifier(id)) {
                        var binding = scope.getBinding(id.name);
                        if (!binding || (binding.referencePaths.some(function (referencePath) { return referencePath.willIMaybeExecuteBefore(path); }) || (binding.referencePaths.length && path.getDeepestCommonAncestorFrom(binding.referencePaths.concat([path])) !== path.parentPath))) {
                            this.targetPath.scope.push({ id: id });
                            if (declaration.node.init) {
                                path.insertBefore(types.expressionStatement(types.assignmentExpression("=", id, declaration.node.init)));
                            }
                            if ((path.parentPath.isForInStatement() || path.parentPath.isForOfStatement()) && path.parentPath.get("left") === path) {
                                path.replaceWith(id);
                            }
                            else {
                                declaration.remove();
                            }
                        }
                    }
                    else {
                        // TODO: Support destructured identifiers
                    }
                }
            }
        },
        FunctionDeclaration: function (path) {
            var siblings = path.getAllPrevSiblings();
            if (siblings.some(function (sibling) { return !sibling.isFunctionDeclaration(); })) {
                var node = path.node;
                var parentPath = path.parentPath;
                path.remove();
                var paths = siblings[0].insertBefore(node);
                if (isNewBabel) {
                    parentPath.scope.registerDeclaration(paths[0]);
                }
            }
        }
    };
    function rewriteThisArgumentsAndHoistFunctions(rewritePath, targetPath) {
        var state = { targetPath: targetPath };
        rewritePath.traverse(rewriteThisArgumentsAndHoistVisitor, state);
        if (state.thisIdentifier) {
            targetPath.scope.push({ id: state.thisIdentifier, init: types.thisExpression() });
        }
        if (state.argumentsIdentifier) {
            targetPath.scope.push({ id: state.argumentsIdentifier, init: types.identifier("arguments") });
        }
    }
    function functionize(expression) {
        if (types.isExpression(expression)) {
            expression = returnStatement(expression);
        }
        if (!types.isBlockStatement(expression)) {
            expression = blockStatement([expression]);
        }
        return types.functionExpression(undefined, [], expression);
    }
    function blockStatement(statementOrStatements) {
        if ("length" in statementOrStatements) {
            return types.blockStatement(statementOrStatements.filter(function (statement) { return !types.isEmptyStatement(statement); }));
        }
        else if (!types.isBlockStatement(statementOrStatements)) {
            return types.blockStatement([statementOrStatements]);
        }
        else {
            return statementOrStatements;
        }
    }
    function unwrapReturnCallWithEmptyArguments(node, scope, additionalConstantNames) {
        if (types.isFunctionExpression(node) && node.body.body.length === 1) {
            var onlyStatement = node.body.body[0];
            if (types.isReturnStatement(onlyStatement)) {
                var expression = onlyStatement.argument;
                if (types.isCallExpression(expression)) {
                    var callTarget = void 0;
                    switch (expression.arguments.length) {
                        case 0:
                            callTarget = expression.callee;
                            break;
                        case 1: {
                            var callee = expression.callee;
                            if (types.isIdentifier(callee) && callee._helperName === "_call") {
                                callTarget = expression.arguments[0];
                            }
                            break;
                        }
                    }
                    if (callTarget) {
                        if (types.isIdentifier(callTarget)) {
                            var binding = scope.getBinding(callTarget.name);
                            if (binding && binding.constant) {
                                return callTarget;
                            }
                            if (additionalConstantNames.indexOf(callTarget.name) !== -1) {
                                return callTarget;
                            }
                        }
                        else if (types.isFunctionExpression(callTarget)) {
                            return callTarget;
                        }
                    }
                }
            }
        }
        return node;
    }
    function unwrapReturnCallWithPassthroughArgument(node, scope) {
        if (types.isFunctionExpression(node) && node.params.length >= 1 && node.body.body.length >= 1) {
            var firstStatement = node.body.body[0];
            if (types.isReturnStatement(firstStatement)) {
                var expression = firstStatement.argument;
                if (types.isCallExpression(expression) && expression.arguments.length === 1) {
                    var firstArgument = expression.arguments[0];
                    var firstParam = node.params[0];
                    if (types.isIdentifier(firstArgument) && types.isIdentifier(firstParam) && firstArgument.name === firstParam.name && types.isIdentifier(expression.callee)) {
                        var binding = scope.getBinding(expression.callee.name);
                        if (binding && binding.constant) {
                            return expression.callee;
                        }
                    }
                }
            }
        }
        return node;
    }
    function isExpressionOfLiterals(path, literalNames) {
        if (path.isIdentifier()) {
            if (path.node.name === "undefined") {
                return true;
            }
            var binding = path.parentPath.scope.getBinding(path.node.name);
            if (binding) {
                return binding.constant;
            }
            if (literalNames.indexOf(path.node.name) !== -1) {
                return true;
            }
            return false;
        }
        if (path.isBooleanLiteral()) {
            return true;
        }
        if (path.isNumericLiteral()) {
            return true;
        }
        if (path.isStringLiteral()) {
            return true;
        }
        if (path.isArrayExpression()) {
            return path.get("elements").every(function (path) { return path === null || path.node === null ? true : isExpressionOfLiterals(path, literalNames); });
        }
        if (path.isObjectExpression()) {
            return path.get("properties").every(function (path) {
                if (!path.isObjectProperty()) {
                    return true;
                }
                if (isExpressionOfLiterals(path.get("value"), literalNames) && (!path.node.computed || isExpressionOfLiterals(path.get("key"), literalNames))) {
                    return true;
                }
                return false;
            });
        }
        if (path.isUnaryExpression()) {
            return isExpressionOfLiterals(path.get("argument"), literalNames);
        }
        if (path.isLogicalExpression() || path.isBinaryExpression()) {
            return isExpressionOfLiterals(path.get("left"), literalNames) && isExpressionOfLiterals(path.get("right"), literalNames);
        }
        if (path.isConditionalExpression()) {
            return isExpressionOfLiterals(path.get("test"), literalNames) && isExpressionOfLiterals(path.get("consequent"), literalNames) && isExpressionOfLiterals(path.get("alternate"), literalNames);
        }
        return false;
    }
    function generateIdentifierForPath(path) {
        var result = path.scope.generateUidIdentifierBasedOnNode(path.node, "temp");
        if (path.isIdentifier() && path.node.name === result.name) {
            return path.scope.generateUidIdentifier("temp");
        }
        return result;
    }
    function booleanLiteral(value, minify) {
        return minify ? types.numericLiteral(value ? 1 : 0) : types.booleanLiteral(value);
    }
    function conditionalExpression(test, consequent, alternate) {
        var looseValue = extractLooseBooleanValue(test);
        if (typeof looseValue !== "undefined") {
            return looseValue ? consequent : alternate;
        }
        while (types.isUnaryExpression(test) && test.operator === "!") {
            test = test.argument;
            var temp = consequent;
            consequent = alternate;
            alternate = consequent;
        }
        if ((isValueLiteral(consequent) && isValueLiteral(alternate) && consequent.value === alternate.value) ||
            (types.isNullLiteral(consequent) && types.isNullLiteral(alternate)) ||
            (types.isIdentifier(consequent) && types.isIdentifier(alternate) && consequent.name === alternate.name)) {
            if (types.isIdentifier(test) || types.isLiteral(test)) {
                return consequent;
            }
        }
        return types.conditionalExpression(test, consequent, alternate);
    }
    function extractBooleanValue(node) {
        if (types.isBooleanLiteral(node)) {
            return node.value;
        }
        if (types.isUnaryExpression(node)) {
            if (node.operator === "!") {
                var result = extractLooseBooleanValue(node.argument);
                return typeof result === "undefined" ? undefined : !result;
            }
            else if (node.operator === "void") {
                return typeof extractLooseBooleanValue(node.argument) !== "undefined" ? false : undefined;
            }
        }
    }
    function extractLooseBooleanValue(node) {
        if (isValueLiteral(node)) {
            return !!node.value;
        }
        if (types.isNullLiteral(node)) {
            return false;
        }
        if (types.isIdentifier(node)) {
            if (alwaysTruthy.includes(node.name)) {
                return true;
            }
            if (node.name === "undefined") {
                return false;
            }
        }
        return extractBooleanValue(node);
    }
    function logicalOr(left, right) {
        if (extractLooseBooleanValue(left) === true) {
            return left;
        }
        else if (extractBooleanValue(left) === false) {
            return right;
        }
        else {
            return types.logicalExpression("||", left, right);
        }
    }
    function logicalOrLoose(left, right, minify) {
        switch (extractLooseBooleanValue(left)) {
            case false:
                return extractLooseBooleanValue(right) === false ? booleanLiteral(false, minify) : right;
            case true:
                return booleanLiteral(true, minify);
            default:
                switch (extractLooseBooleanValue(right)) {
                    case false:
                        return left;
                    case true:
                        return booleanLiteral(true, minify);
                    default:
                        return types.logicalExpression("||", left, right);
                }
        }
    }
    function logicalAnd(left, right, extract) {
        if (extract === void 0) { extract = extractBooleanValue; }
        switch (extract(left)) {
            case true:
                return left;
            case false:
                return right;
            default:
                return types.logicalExpression("&&", left, right);
        }
    }
    function logicalNot(node, minify) {
        var literalValue = extractLooseBooleanValue(node);
        if (typeof literalValue !== "undefined") {
            return booleanLiteral(!literalValue, minify);
        }
        if (types.isUnaryExpression(node) && node.operator === "!" && types.isUnaryExpression(node.argument) && node.argument.operator === "!") {
            return node.argument;
        }
        return types.unaryExpression("!", node);
    }
    function unwrapSpreadElement(path) {
        if (path.isExpression()) {
            return path;
        }
        if (path.isSpreadElement()) {
            return path.get("argument");
        }
        throw path.buildCodeFrameError("Expected either an expression or a spread element, got a " + path.type + "!");
    }
    function findDeclarationToReuse(path) {
        for (;;) {
            var parent = path.parentPath;
            if (parent.isVariableDeclarator()) {
                var id = parent.get("id");
                if (id.isIdentifier() || id.isPattern()) {
                    return parent;
                }
            }
            var other = void 0;
            if (parent.isConditionalExpression()) {
                var test = parent.get("test");
                if (path === test) {
                    break;
                }
                var consequent = parent.get("consequent");
                var alternate = parent.get("alternate");
                other = consequent === path ? alternate : consequent;
            }
            else if (parent.isLogicalExpression()) {
                var left = parent.get("left");
                var right = parent.get("right");
                other = left === path ? right : left;
            }
            else {
                break;
            }
            var otherAwaitPath = findAwaitPath(other);
            if ((otherAwaitPath === other) || !otherAwaitPath) {
                path = path.parentPath;
            }
            else {
                break;
            }
        }
    }
    function extractDeclarations(state, originalAwaitPath, awaitExpression, additionalConstantNames) {
        var awaitPath = originalAwaitPath;
        var reusingExisting = findDeclarationToReuse(awaitPath);
        var reusingExistingId = reusingExisting ? reusingExisting.get("id") : undefined;
        var existingIdentifier = reusingExistingId && (reusingExistingId.isIdentifier() || reusingExistingId.isPattern()) ? reusingExistingId.node : undefined;
        var resultIdentifier;
        if (awaitPath.parentPath.isSequenceExpression() && (awaitPath.key < awaitPath.container.length - 1)) {
            originalAwaitPath.replaceWith(types.numericLiteral(0));
        }
        else {
            var newIdentifier = resultIdentifier = existingIdentifier || generateIdentifierForPath(originalAwaitPath.get("argument"));
            originalAwaitPath.replaceWith(types.isIdentifier(newIdentifier) ? newIdentifier : types.numericLiteral(0));
        }
        var declarations = [];
        var directExpression = booleanLiteral(false, state.opts.minify);
        var _loop_1 = function () {
            var parent = awaitPath.parentPath;
            if (parent.isVariableDeclarator()) {
                var beforeDeclarations = [];
                while (parent.key !== 0) {
                    var sibling = parent.getSibling(0);
                    if (sibling.isVariableDeclarator()) {
                        beforeDeclarations.push(sibling.node);
                        sibling.remove();
                    }
                    else {
                        throw sibling.buildCodeFrameError("Expected a variable declarator, got a " + sibling.type + "!");
                    }
                }
                if (beforeDeclarations.length) {
                    declarations = declarations.concat(beforeDeclarations.concat(declarations));
                }
            }
            else if (parent.isLogicalExpression()) {
                var left = parent.get("left");
                if (awaitPath !== left) {
                    if (!isExpressionOfLiterals(left, additionalConstantNames)) {
                        var leftIdentifier_1 = generateIdentifierForPath(left);
                        declarations = declarations.map(function (declaration) { return declaration.init ? types.variableDeclarator(declaration.id, logicalAnd(parent.node.operator === "||" ? logicalNot(leftIdentifier_1) : leftIdentifier_1, declaration.init)) : declaration; });
                        declarations.unshift(types.variableDeclarator(leftIdentifier_1, left.node));
                        left.replaceWith(leftIdentifier_1);
                    }
                    var isOr = parent.node.operator === "||";
                    awaitExpression = (isOr ? logicalOr : logicalAnd)(left.node, awaitExpression);
                    directExpression = logicalOrLoose(isOr ? left.node : logicalNot(left.node), directExpression, state.opts.minify);
                    if (awaitPath === originalAwaitPath) {
                        if (!resultIdentifier) {
                            resultIdentifier = existingIdentifier || generateIdentifierForPath(originalAwaitPath.get("argument"));
                        }
                        parent.replaceWith(resultIdentifier);
                        awaitPath = parent;
                        return "continue";
                    }
                }
            }
            else if (parent.isBinaryExpression()) {
                var left = parent.get("left");
                if (awaitPath !== left) {
                    if (!isExpressionOfLiterals(left, additionalConstantNames)) {
                        var leftIdentifier = generateIdentifierForPath(left);
                        declarations.unshift(types.variableDeclarator(leftIdentifier, left.node));
                        left.replaceWith(leftIdentifier);
                    }
                }
            }
            else if (parent.isSequenceExpression()) {
                var children = parent.get("expressions");
                var position = children.indexOf(awaitPath);
                for (var i = 0; i < position; i++) {
                    var expression = children[i];
                    if (!isExpressionOfLiterals(expression, additionalConstantNames)) {
                        var sequenceIdentifier = generateIdentifierForPath(expression);
                        declarations.unshift(types.variableDeclarator(sequenceIdentifier, expression.node));
                    }
                    expression.remove();
                }
                if (position === children.length - 1) {
                    parent.replaceWith(children[position]);
                }
            }
            else if (parent.isConditionalExpression()) {
                var test = parent.get("test");
                if (awaitPath !== test) {
                    var testNode_1 = test.node;
                    var consequent_1 = parent.get("consequent");
                    var alternate = parent.get("alternate");
                    var other = consequent_1 === awaitPath ? alternate : consequent_1;
                    var otherAwaitPath = findAwaitPath(other);
                    var testIdentifier_1;
                    var isBoth = consequent_1 === awaitPath && otherAwaitPath === alternate;
                    if (!(isBoth && awaitPath === originalAwaitPath) && !isExpressionOfLiterals(test, additionalConstantNames)) {
                        testIdentifier_1 = generateIdentifierForPath(test);
                    }
                    declarations = declarations.map(function (declaration) { return declaration.init ? types.variableDeclarator(declaration.id, (consequent_1 === awaitPath ? logicalAnd : logicalOr)(testIdentifier_1 || testNode_1, declaration.init)) : declaration; });
                    if (testIdentifier_1) {
                        declarations.unshift(types.variableDeclarator(testIdentifier_1, testNode_1));
                        test.replaceWith(testIdentifier_1);
                        testNode_1 = testIdentifier_1;
                    }
                    if (isBoth && otherAwaitPath) {
                        awaitExpression = conditionalExpression(testNode_1, awaitExpression, otherAwaitPath.node.argument);
                        if (!resultIdentifier) {
                            resultIdentifier = existingIdentifier || generateIdentifierForPath(originalAwaitPath.get("argument"));
                        }
                        alternate.replaceWith(resultIdentifier);
                        parent.replaceWith(resultIdentifier);
                    }
                    else {
                        directExpression = logicalOrLoose(consequent_1 !== awaitPath ? testNode_1 : logicalNot(testNode_1), directExpression, state.opts.minify);
                        if (otherAwaitPath) {
                            awaitExpression = consequent_1 !== awaitPath ? conditionalExpression(testNode_1, types.numericLiteral(0), awaitExpression) : conditionalExpression(testNode_1, awaitExpression, types.numericLiteral(0));
                        }
                        else {
                            awaitExpression = consequent_1 !== awaitPath ? conditionalExpression(testNode_1, other.node, awaitExpression) : conditionalExpression(testNode_1, awaitExpression, other.node);
                            if (!resultIdentifier) {
                                resultIdentifier = existingIdentifier || generateIdentifierForPath(originalAwaitPath.get("argument"));
                            }
                            if (awaitPath === originalAwaitPath) {
                                parent.replaceWith(resultIdentifier);
                                awaitPath = parent;
                                return "continue";
                            }
                            other.replaceWith(resultIdentifier);
                        }
                    }
                }
            }
            else if (parent.isCallExpression()) {
                var callee = parent.get("callee");
                if (callee !== awaitPath) {
                    for (var _i = 0, _a = parent.get("arguments"); _i < _a.length; _i++) {
                        var arg = _a[_i];
                        var spreadArg = unwrapSpreadElement(arg);
                        if (spreadArg === awaitPath || arg === awaitPath) {
                            break;
                        }
                        if (!isExpressionOfLiterals(spreadArg, additionalConstantNames)) {
                            var argIdentifier = generateIdentifierForPath(spreadArg);
                            declarations.unshift(types.variableDeclarator(argIdentifier, spreadArg.node));
                            spreadArg.replaceWith(argIdentifier);
                        }
                    }
                    if (!isExpressionOfLiterals(callee, additionalConstantNames)) {
                        if (callee.isMemberExpression()) {
                            var object = callee.get("object");
                            if (!isExpressionOfLiterals(object, additionalConstantNames)) {
                                var objectIdentifier = generateIdentifierForPath(object);
                                declarations.unshift(types.variableDeclarator(objectIdentifier, object.node));
                                object.replaceWith(objectIdentifier);
                            }
                            var property = callee.get("property");
                            var calleeIdentifier = generateIdentifierForPath(property);
                            var calleeNode = callee.node;
                            var newArguments = [object.node];
                            parent.replaceWith(types.callExpression(types.memberExpression(calleeIdentifier, types.identifier("call")), newArguments.concat(parent.node.arguments)));
                            declarations.unshift(types.variableDeclarator(calleeIdentifier, calleeNode));
                        }
                        else if (!callee.isIdentifier() || !(callee.node._helperName || (awaitPath.scope.getBinding(callee.node.name) || { constant: false }).constant)) {
                            var calleeIdentifier = generateIdentifierForPath(callee);
                            var calleeNode = callee.node;
                            callee.replaceWith(calleeIdentifier);
                            declarations.unshift(types.variableDeclarator(calleeIdentifier, calleeNode));
                        }
                    }
                }
            }
            else if (parent.isArrayExpression()) {
                for (var _b = 0, _c = parent.get("elements"); _b < _c.length; _b++) {
                    var element = _c[_b];
                    var spreadElement = unwrapSpreadElement(element);
                    if (element === awaitPath || spreadElement === awaitPath) {
                        break;
                    }
                    if (!isExpressionOfLiterals(spreadElement, additionalConstantNames)) {
                        var elementIdentifier = generateIdentifierForPath(spreadElement);
                        declarations.unshift(types.variableDeclarator(elementIdentifier, spreadElement.node));
                        spreadElement.replaceWith(elementIdentifier);
                    }
                }
            }
            else if (parent.isObjectExpression()) {
                for (var _d = 0, _e = parent.get("properties"); _d < _e.length; _d++) {
                    var prop = _e[_d];
                    if (prop === awaitPath) {
                        break;
                    }
                    if (prop.isObjectProperty()) {
                        if (prop.node.computed) {
                            var propKey = prop.get("key");
                            if (propKey === awaitPath) {
                                break;
                            }
                            if (!isExpressionOfLiterals(propKey, additionalConstantNames)) {
                                var keyIdentifier = generateIdentifierForPath(propKey);
                                declarations.unshift(types.variableDeclarator(keyIdentifier, propKey.node));
                                propKey.replaceWith(keyIdentifier);
                            }
                        }
                        var propValue = prop.get("value");
                        if (propValue === awaitPath) {
                            break;
                        }
                        if (!isExpressionOfLiterals(propValue, additionalConstantNames)) {
                            var propIdentifier = generateIdentifierForPath(propValue);
                            declarations.unshift(types.variableDeclarator(propIdentifier, propValue.node));
                            propValue.replaceWith(propIdentifier);
                        }
                    }
                }
            }
            if (parent.isStatement()) {
                return { value: { declarations: declarations, awaitExpression: awaitExpression, directExpression: directExpression, reusingExisting: reusingExisting, resultIdentifier: resultIdentifier } };
            }
            else {
                awaitPath = parent;
            }
        };
        for (;;) {
            var state_1 = _loop_1();
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    function skipNode(path) {
        path.skip();
    }
    var awaitPathVisitor = {
        Function: skipNode,
        AwaitExpression: function (path) {
            this.result = path;
            path.stop();
        }
    };
    function findAwaitPath(path) {
        if (path.isAwaitExpression()) {
            return path;
        }
        var state = {};
        path.traverse(awaitPathVisitor, state);
        var result = state.result;
        if (result && result.isAwaitExpression()) {
            return result;
        }
    }
    function buildBreakExitCheck(state, exitIdentifier, breakIdentifiers) {
        var expressions = (breakIdentifiers.map(function (identifier) { return identifier.identifier; }) || []).concat(exitIdentifier ? [exitIdentifier] : []);
        if (expressions.length) {
            return expressions.reduce(function (accumulator, identifier) { return logicalOrLoose(accumulator, identifier, state.opts.minify); });
        }
    }
    function pushMissing(destination, source) {
        for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {
            var value = source_1[_i];
            var index = destination.indexOf(value);
            if (index < 0) {
                destination.push(value);
            }
        }
    }
    function setBreakIdentifier(value, breakIdentifier) {
        return types.assignmentExpression("=", breakIdentifier.identifier, value);
    }
    function setBreakIdentifiers(breakIdentifiers, pluginState) {
        return breakIdentifiers.reduce(setBreakIdentifier, booleanLiteral(true, pluginState.opts.minify));
    }
    var replaceReturnsAndBreaksVisitor = {
        Function: skipNode,
        ReturnStatement: function (path) {
            if (!path.node._skip && this.exitIdentifier) {
                var minify = this.pluginState.opts.minify;
                if (minify && path.node.argument && extractLooseBooleanValue(path.node.argument) === true) {
                    path.replaceWith(returnStatement(types.assignmentExpression("=", this.exitIdentifier, path.node.argument), path.node));
                }
                else {
                    path.replaceWithMultiple([
                        types.expressionStatement(types.assignmentExpression("=", this.exitIdentifier, booleanLiteral(true, minify))),
                        returnStatement(path.node.argument, path.node),
                    ]);
                }
            }
        },
        BreakStatement: function (path) {
            var replace = returnStatement(undefined, path.node);
            var label = path.node.label;
            var index = label ? this.breakIdentifiers.findIndex(function (breakIdentifier) { return breakIdentifier.name === label.name; }) : 0;
            if (index !== -1 && this.breakIdentifiers.length) {
                var used = this.breakIdentifiers.slice(0, index + 1);
                if (used.length) {
                    pushMissing(this.usedIdentifiers, used);
                    path.replaceWithMultiple([
                        types.expressionStatement(setBreakIdentifiers(used, this.pluginState)),
                        replace,
                    ]);
                    return;
                }
            }
            path.replaceWith(replace);
        },
        ContinueStatement: function (path) {
            var replace = returnStatement(undefined, path.node);
            var label = path.node.label;
            var index = label ? this.breakIdentifiers.findIndex(function (breakIdentifier) { return breakIdentifier.name === label.name; }) : 0;
            if (index !== -1 && this.breakIdentifiers.length) {
                var used = this.breakIdentifiers.slice(0, index);
                if (used.length) {
                    pushMissing(this.usedIdentifiers, used);
                    path.replaceWithMultiple([
                        types.expressionStatement(setBreakIdentifiers(used, this.pluginState)),
                        replace,
                    ]);
                    return;
                }
            }
            path.replaceWith(replace);
        }
    };
    function replaceReturnsAndBreaks(pluginState, path, exitIdentifier) {
        var state = { pluginState: pluginState, exitIdentifier: exitIdentifier, breakIdentifiers: breakContinueStackForPath(path), usedIdentifiers: [] };
        path.traverse(replaceReturnsAndBreaksVisitor, state);
        for (var _i = 0, _a = state.usedIdentifiers; _i < _a.length; _i++) {
            var identifier = _a[_i];
            if (!identifier.path.parentPath.scope.getBinding(identifier.identifier.name)) {
                identifier.path.parentPath.scope.push({ id: identifier.identifier, init: pluginState.opts.minify ? undefined : booleanLiteral(false, pluginState.opts.minify) });
            }
        }
        return state.usedIdentifiers;
    }
    function breakIdentifierForPath(path) {
        var result = path.node._breakIdentifier;
        if (!result) {
            result = path.node._breakIdentifier = path.scope.generateUidIdentifier(path.parentPath.isLabeledStatement() ? path.parentPath.node.label.name + "Interrupt" : "interrupt");
        }
        return result;
    }
    var simpleBreakOrContinueReferencesVisitor = {
        Function: skipNode,
        Loop: skipNode,
        SwitchStatement: skipNode,
        BreakStatement: function (path) {
            if (!path.node.label) {
                this.references.push(path);
            }
        },
        // ContinueStatement(path) {
        // 	if (!path.node.label) {
        // 		this.references.push(path);
        // 	}
        // },
        ReturnStatement: function (path) {
            var originalNode = path.node._originalNode;
            if (originalNode) {
                traverse(wrapNodeInStatement(originalNode), simpleBreakOrContinueReferencesVisitor, path.scope, this, path);
                path.skip();
            }
        }
    };
    function simpleBreakOrContinueReferences(path) {
        var state = { references: [] };
        path.traverse(simpleBreakOrContinueReferencesVisitor, state);
        return state.references;
    }
    var namedLabelReferencesVisitor = {
        Function: skipNode,
        BreakStatement: function (path) {
            if (path.node.label && path.node.label.name === this.name) {
                this.breaks.push(path);
            }
        },
        ContinueStatement: function (path) {
            if (path.node.label && path.node.label.name === this.name) {
                this.continues.push(path);
            }
        },
        ReturnStatement: function (path) {
            var originalNode = path.node._originalNode;
            if (originalNode) {
                traverse(wrapNodeInStatement(originalNode), namedLabelReferencesVisitor, path.scope, this, path);
                path.skip();
            }
        }
    };
    function namedLabelReferences(labelPath, targetPath) {
        var state = { name: labelPath.node.label.name, breaks: [], continues: [] };
        targetPath.traverse(namedLabelReferencesVisitor, state);
        return state;
    }
    function breakContinueStackForPath(path) {
        var current = path;
        var result = [];
        while (current && !current.isFunction()) {
            if (current.isLoop() || current.isSwitchStatement()) {
                var breaks = pathsBreak(current);
                if (breaks.any && !breaks.all) {
                    var simpleReferences = simpleBreakOrContinueReferences(current);
                    if (current.parentPath.isLabeledStatement()) {
                        var refs = namedLabelReferences(current.parentPath, path);
                        if (simpleReferences.length || refs.breaks.length || refs.continues.length) {
                            result.push({
                                identifier: breakIdentifierForPath(current),
                                name: current.parentPath.node.label.name,
                                path: current.parentPath
                            });
                        }
                        current = current.parentPath;
                    }
                    else if (simpleReferences.length) {
                        result.push({
                            identifier: breakIdentifierForPath(current),
                            path: current
                        });
                    }
                }
            }
            else if (current.isLabeledStatement()) {
                var refs = namedLabelReferences(current, path);
                if (refs.breaks.length || refs.continues.length) {
                    result.push({
                        identifier: breakIdentifierForPath(current.get("body")),
                        name: current.node.label.name,
                        path: current
                    });
                }
            }
            current = current.parentPath;
        }
        return result;
    }
    function isForAwaitStatement(path) {
        return path.isForAwaitStatement ? path.isForAwaitStatement() : false;
    }
    function getStatementParent(path) {
        var parent = path;
        do {
            if (parent.isStatement()) {
                return parent;
            }
        } while (parent = parent.parentPath);
        throw path.buildCodeFrameError("Expected a statement parent!");
    }
    function addConstantNames(additionalConstantNames, node) {
        if (types.isIdentifier(node)) {
            if (additionalConstantNames.indexOf(node.name) === -1) {
                additionalConstantNames.push(node.name);
            }
        }
        else if (types.isArrayPattern(node)) {
            for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                if (types.isIdentifier(element) || types.isPattern(element) || types.isRestElement(element)) {
                    addConstantNames(additionalConstantNames, element);
                }
            }
        }
        else if (types.isObjectPattern(node)) {
            for (var _b = 0, _c = node.properties; _b < _c.length; _b++) {
                var property = _c[_b];
                if (types.isObjectProperty(property)) {
                    addConstantNames(additionalConstantNames, property.key);
                }
                else if (types.isRestProperty(property)) {
                    addConstantNames(additionalConstantNames, property.argument);
                }
            }
        }
        else if (types.isRestElement(node)) {
            addConstantNames(additionalConstantNames, node.argument);
        }
    }
    function rewriteAwaitPath(rewritePath) {
        var _this = this;
        var state = this;
        var pluginState = state.pluginState;
        var path = state.path;
        var additionalConstantNames = state.additionalConstantNames;
        var awaitPath;
        var processExpressions;
        var rewritePathCopy = rewritePath;
        if (rewritePath.isAwaitExpression()) {
            awaitPath = rewritePath;
            processExpressions = true;
        }
        else if (rewritePath.isForOfStatement() || isForAwaitStatement(rewritePath)) {
            var left = rewritePath.get("left");
            if (left.isAwaitExpression()) {
                awaitPath = left.get("argument");
            }
            else if (left.isSpreadElement()) {
                awaitPath = unwrapSpreadElement(left);
            }
            else {
                awaitPath = left;
            }
            processExpressions = false;
        }
        else {
            throw rewritePathCopy.buildCodeFrameError("Expected either an await expression or a for await statement, got a " + rewritePathCopy.type + "!");
        }
        var paths = [];
        {
            // Determine if we need an exit identifier and rewrite break/return statements
            var targetPath = awaitPath;
            var shouldPushExitIdentifier = false;
            while (targetPath !== path) {
                var parent = targetPath.parentPath;
                if (!parent.isSwitchCase() && !parent.isBlockStatement()) {
                    var exitIdentifier = void 0;
                    var explicitExits = pathsReturnOrThrow(parent);
                    if (!explicitExits.all && explicitExits.any && (parent.isLoop() || exitsInTail(parent))) {
                        if (!state.exitIdentifier) {
                            state.exitIdentifier = targetPath.scope.generateUidIdentifier("exit");
                            shouldPushExitIdentifier = true;
                        }
                        exitIdentifier = state.exitIdentifier;
                    }
                    paths.push({
                        targetPath: targetPath,
                        explicitExits: explicitExits,
                        parent: parent,
                        exitIdentifier: exitIdentifier
                    });
                }
                targetPath = parent;
            }
            if (shouldPushExitIdentifier) {
                path.scope.push({ id: state.exitIdentifier, init: state.pluginState.opts.minify ? undefined : booleanLiteral(false, state.pluginState.opts.minify) });
            }
        }
        var _loop_2 = function (item) {
            var parent = item.parent;
            if (parent.isForStatement() || parent.isWhileStatement() || parent.isDoWhileStatement() || parent.isForInStatement() || parent.isForOfStatement() || isForAwaitStatement(parent) || parent.isLabeledStatement()) {
                item.breakIdentifiers = replaceReturnsAndBreaks(this_1.pluginState, parent.get("body"), item.exitIdentifier);
                if (parent.isForStatement()) {
                    if (item.forToIdentifiers = identifiersInForToLengthStatement(parent)) {
                        addConstantNames(additionalConstantNames, item.forToIdentifiers.i);
                    }
                }
            }
            else if (item.parent.isSwitchStatement()) {
                item.cases = item.parent.get("cases").map(function (casePath) {
                    return {
                        casePath: casePath,
                        caseExits: pathsReturnOrThrow(casePath),
                        caseBreaks: pathsBreak(casePath),
                        breakIdentifiers: replaceReturnsAndBreaks(_this.pluginState, casePath, item.exitIdentifier),
                        test: casePath.node.test
                    };
                });
            }
            else if (item.exitIdentifier) {
                replaceReturnsAndBreaks(this_1.pluginState, parent, item.exitIdentifier);
            }
        };
        var this_1 = this;
        for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
            var item = paths_1[_i];
            _loop_2(item);
        }
        var _loop_3 = function (targetPath, explicitExits, breakIdentifiers, parent, exitIdentifier, cases, forToIdentifiers) {
            if (parent.isIfStatement()) {
                var test = parent.get("test");
                if (targetPath !== test) {
                    var resultIdentifier = void 0;
                    if (!explicitExits.all && explicitExits.any) {
                        resultIdentifier = path.scope.generateUidIdentifier("result");
                        addConstantNames(additionalConstantNames, resultIdentifier);
                    }
                    if (!explicitExits.all) {
                        var consequent = parent.get("consequent");
                        var consequentNode = rewriteAsyncNode(pluginState, parent, consequent.node, additionalConstantNames, exitIdentifier);
                        var alternate = parent.get("alternate");
                        var alternateNode = alternate.node ? rewriteAsyncNode(pluginState, parent, alternate.node, additionalConstantNames, exitIdentifier) : undefined;
                        var fn = types.functionExpression(undefined, [], blockStatement([types.ifStatement(test.node, consequentNode, alternateNode)]));
                        relocateTail(pluginState, types.callExpression(fn, []), undefined, parent, additionalConstantNames, resultIdentifier, exitIdentifier);
                        processExpressions = false;
                    }
                }
            }
            else if (parent.isTryStatement()) {
                var temporary = explicitExits.any && !explicitExits.all ? path.scope.generateUidIdentifier("result") : undefined;
                var exitCheck = buildBreakExitCheck(this_2.pluginState, explicitExits.any && !explicitExits.all ? exitIdentifier : undefined, []);
                var expression = rewriteAsyncNode(pluginState, parent, parent.node.block, additionalConstantNames, exitIdentifier);
                var catchClause = parent.node.handler;
                if (catchClause) {
                    var param = catchClause.param;
                    var paramIsUsed = parent.get("handler").scope.getBinding(param.name).referencePaths.length !== 0;
                    var fn = catchClause.body.body.length ? rewriteAsyncNode(pluginState, parent, types.functionExpression(undefined, paramIsUsed ? [param] : [], catchClause.body), additionalConstantNames, exitIdentifier) : helperReference(pluginState, parent, "_empty");
                    expression = types.callExpression(helperReference(pluginState, path, "_catch"), [unwrapReturnCallWithEmptyArguments(functionize(expression), path.scope, additionalConstantNames), fn]);
                }
                if (parent.node.finalizer) {
                    var finallyName = void 0;
                    var finallyArgs = void 0;
                    var finallyBody = parent.node.finalizer.body;
                    if (!pathsReturnOrThrow(parent.get("finalizer")).all) {
                        var resultIdentifier = temporary || path.scope.generateUidIdentifier("result");
                        addConstantNames(additionalConstantNames, resultIdentifier);
                        var wasThrownIdentifier = path.scope.generateUidIdentifier("wasThrown");
                        addConstantNames(additionalConstantNames, wasThrownIdentifier);
                        finallyArgs = [wasThrownIdentifier, resultIdentifier];
                        finallyBody = finallyBody.concat(returnStatement(types.callExpression(helperReference(pluginState, parent, "_rethrow"), [wasThrownIdentifier, resultIdentifier])));
                        finallyName = "_finallyRethrows";
                    }
                    else {
                        finallyArgs = [];
                        finallyName = "_finally";
                    }
                    var fn = types.functionExpression(undefined, finallyArgs, blockStatement(finallyBody));
                    var rewritten = rewriteAsyncNode(pluginState, parent, fn, additionalConstantNames, exitIdentifier);
                    expression = types.callExpression(helperReference(pluginState, parent, finallyName), [unwrapReturnCallWithEmptyArguments(functionize(expression), path.scope, additionalConstantNames), rewritten]);
                }
                relocateTail(pluginState, types.isExpression(expression) ? expression : types.callExpression(functionize(expression), []), undefined, parent, additionalConstantNames, temporary, exitCheck);
                processExpressions = false;
            }
            else if (parent.isForStatement() || parent.isWhileStatement() || parent.isDoWhileStatement() || parent.isForInStatement() || parent.isForOfStatement() || isForAwaitStatement(parent)) {
                var breaks = pathsBreak(parent);
                var label = parent.parentPath.isLabeledStatement() ? parent.parentPath.node.label.name : undefined;
                if (parent.isForInStatement() || parent.isForOfStatement() || isForAwaitStatement(parent)) {
                    var right = parent.get("right");
                    if (awaitPath !== right) {
                        var left = parent.get("left");
                        var loopIdentifier = left.isVariableDeclaration() ? left.get("declarations")[0].get("id") : left;
                        if (loopIdentifier.isIdentifier() || loopIdentifier.isPattern()) {
                            var forOwnBodyPath = parent.isForInStatement() && extractForOwnBodyPath(parent);
                            var bodyBlock = blockStatement((forOwnBodyPath || parent.get("body")).node);
                            var params = [right.node, rewriteAsyncNode(pluginState, parent, bodyBlock.body.length ? types.functionExpression(undefined, [loopIdentifier.node], bodyBlock) : helperReference(pluginState, parent, "_empty"), additionalConstantNames, exitIdentifier)];
                            var exitCheck = buildBreakExitCheck(this_2.pluginState, exitIdentifier, breakIdentifiers || []);
                            if (exitCheck) {
                                params.push(types.functionExpression(undefined, [], types.blockStatement([returnStatement(exitCheck)])));
                            }
                            var loopCall = types.callExpression(helperReference(pluginState, parent, parent.isForInStatement() ? forOwnBodyPath ? "_forOwn" : "_forIn" : isForAwaitStatement(parent) ? "_forAwaitOf" : "_forOf"), params);
                            var resultIdentifier = undefined;
                            if (explicitExits.any) {
                                resultIdentifier = path.scope.generateUidIdentifier("result");
                                addConstantNames(additionalConstantNames, resultIdentifier);
                            }
                            relocateTail(pluginState, loopCall, undefined, label && parent.parentPath.isStatement() ? parent.parentPath : parent, additionalConstantNames, resultIdentifier, exitIdentifier);
                            processExpressions = false;
                        }
                        else {
                            throw loopIdentifier.buildCodeFrameError("Expected an identifier or pattern, but got a " + loopIdentifier.type + "!");
                        }
                    }
                }
                else {
                    var testExpression = parent.node.test;
                    var breakExitCheck = buildBreakExitCheck(this_2.pluginState, exitIdentifier, breakIdentifiers || []);
                    if (breakExitCheck) {
                        var inverted = logicalNot(breakExitCheck, this_2.pluginState.opts.minify);
                        testExpression = testExpression && (!types.isBooleanLiteral(testExpression) || !testExpression.value) ? logicalAnd(inverted, testExpression, extractLooseBooleanValue) : inverted;
                    }
                    if (testExpression) {
                        testExpression = rewriteAsyncNode(pluginState, parent, functionize(testExpression), additionalConstantNames, exitIdentifier, true);
                    }
                    var isDoWhile = parent.isDoWhileStatement();
                    if (!breaks.any && !explicitExits.any && forToIdentifiers && !isDoWhile) {
                        var loopCall = types.callExpression(helperReference(pluginState, parent, "_forTo"), [forToIdentifiers.array, rewriteAsyncNode(pluginState, parent, types.functionExpression(undefined, [forToIdentifiers.i], blockStatement(parent.node.body)), additionalConstantNames, exitIdentifier)]);
                        relocateTail(pluginState, loopCall, undefined, parent, additionalConstantNames, undefined, exitIdentifier);
                    }
                    else {
                        var updateExpression = null;
                        if (parent.isForStatement()) {
                            updateExpression = parent.node.update;
                            if (updateExpression) {
                                updateExpression = rewriteAsyncNode(pluginState, parent, functionize(updateExpression), additionalConstantNames, exitIdentifier, true);
                            }
                            var init = parent.get("init");
                            if (init.node) {
                                parent.insertBefore(init.node);
                            }
                        }
                        var forIdentifier = path.scope.generateUidIdentifier("for");
                        var bodyFunction = rewriteAsyncNode(pluginState, parent, types.functionExpression(undefined, [], blockStatement(parent.node.body)), additionalConstantNames, exitIdentifier);
                        var testFunction = unwrapReturnCallWithEmptyArguments(testExpression || voidExpression(), path.scope, additionalConstantNames);
                        var updateFunction = unwrapReturnCallWithEmptyArguments(updateExpression || voidExpression(), path.scope, additionalConstantNames);
                        var loopCall = isDoWhile ? types.callExpression(helperReference(pluginState, parent, "_do"), [bodyFunction, testFunction]) : types.callExpression(helperReference(pluginState, parent, "_for"), [testFunction, updateFunction, bodyFunction]);
                        var resultIdentifier = undefined;
                        if (explicitExits.any) {
                            resultIdentifier = path.scope.generateUidIdentifier("result");
                            addConstantNames(additionalConstantNames, resultIdentifier);
                        }
                        relocateTail(pluginState, loopCall, undefined, parent, additionalConstantNames, resultIdentifier, exitIdentifier);
                    }
                    processExpressions = false;
                }
            }
            else if (parent.isSwitchStatement()) {
                var label = parent.parentPath.isLabeledStatement() ? parent.parentPath.node.label.name : undefined;
                var discriminant = parent.get("discriminant");
                var testPaths = parent.get("cases").map(function (casePath) { return casePath.get("test"); });
                if (awaitPath !== discriminant && !(explicitExits.all && !testPaths.some(function (testPath) { return testPath.node ? findAwaitPath(testPath) !== undefined : false; }))) {
                    var resultIdentifier = void 0;
                    if (!explicitExits.all && explicitExits.any) {
                        resultIdentifier = path.scope.generateUidIdentifier("result");
                        addConstantNames(additionalConstantNames, resultIdentifier);
                    }
                    var caseNodes = types.arrayExpression(cases ? cases.map(function (caseItem) {
                        var args = [];
                        var consequent;
                        if (caseItem.casePath.node.consequent) {
                            var rewritten = rewriteAsyncNode(pluginState, parent, blockStatement(removeUnnecessaryReturnStatements(caseItem.casePath.node.consequent)), additionalConstantNames, exitIdentifier);
                            if (rewritten.body.length) {
                                consequent = types.functionExpression(undefined, [], rewritten);
                            }
                        }
                        if (caseItem.casePath.node.test) {
                            args.push(rewriteAsyncNode(pluginState, parent, functionize(caseItem.casePath.node.test), additionalConstantNames));
                        }
                        else if (consequent) {
                            args.push(voidExpression());
                        }
                        if (consequent) {
                            var useBreakIdentifier = !caseItem.caseBreaks.all && caseItem.caseBreaks.any;
                            args.push(consequent);
                            if (!caseItem.caseExits.any && !caseItem.caseBreaks.any) {
                                args.push(helperReference(pluginState, parent, "_empty"));
                            }
                            else if (!(caseItem.caseExits.all || caseItem.caseBreaks.all)) {
                                var breakCheck = buildBreakExitCheck(_this.pluginState, caseItem.caseExits.any ? exitIdentifier : undefined, caseItem.breakIdentifiers);
                                if (breakCheck) {
                                    args.push(types.functionExpression(undefined, [], types.blockStatement([returnStatement(breakCheck)])));
                                }
                            }
                        }
                        return types.arrayExpression(args);
                    }) : []);
                    var switchCall = types.callExpression(helperReference(pluginState, parent, "_switch"), [discriminant.node, caseNodes]);
                    relocateTail(pluginState, switchCall, undefined, label && parent.parentPath.isStatement() ? parent.parentPath : parent, additionalConstantNames, resultIdentifier, exitIdentifier);
                    processExpressions = false;
                }
            }
            else if (parent.isLabeledStatement()) {
                var resultIdentifier = void 0;
                if (!explicitExits.all && explicitExits.any) {
                    resultIdentifier = path.scope.generateUidIdentifier("result");
                    addConstantNames(additionalConstantNames, resultIdentifier);
                }
                if (resultIdentifier || (breakIdentifiers && breakIdentifiers.length)) {
                    var filteredBreakIdentifiers = breakIdentifiers ? breakIdentifiers.filter(function (id) { return id.name !== parent.node.label.name; }) : [];
                    var fn = types.functionExpression(undefined, [], blockStatement(parent.node.body));
                    var rewritten = rewriteAsyncNode(pluginState, parent, fn, additionalConstantNames, exitIdentifier);
                    var exitCheck = buildBreakExitCheck(this_2.pluginState, explicitExits.any ? exitIdentifier : undefined, filteredBreakIdentifiers);
                    relocateTail(pluginState, types.callExpression(rewritten, []), undefined, parent, additionalConstantNames, resultIdentifier, exitCheck);
                    processExpressions = false;
                }
            }
        };
        var this_2 = this;
        for (var _a = 0, paths_2 = paths; _a < paths_2.length; _a++) {
            var _b = paths_2[_a], targetPath = _b.targetPath, explicitExits = _b.explicitExits, breakIdentifiers = _b.breakIdentifiers, parent = _b.parent, exitIdentifier = _b.exitIdentifier, cases = _b.cases, forToIdentifiers = _b.forToIdentifiers;
            _loop_3(targetPath, explicitExits, breakIdentifiers, parent, exitIdentifier, cases, forToIdentifiers);
        }
        if (processExpressions) {
            if (awaitPath.isAwaitExpression()) {
                var originalArgument = awaitPath.node.argument;
                if (awaitPath.parentPath.isExpressionStatement()) {
                    relocateTail(pluginState, originalArgument, undefined, awaitPath.parentPath, additionalConstantNames, undefined, undefined, booleanLiteral(false, this.pluginState.opts.minify));
                }
                else {
                    var parent = getStatementParent(awaitPath);
                    var _c = extractDeclarations(this.pluginState, awaitPath, originalArgument, additionalConstantNames), declarations = _c.declarations, awaitExpression = _c.awaitExpression, directExpression = _c.directExpression, reusingExisting = _c.reusingExisting, resultIdentifier = _c.resultIdentifier;
                    if (resultIdentifier) {
                        addConstantNames(additionalConstantNames, resultIdentifier);
                    }
                    if (declarations.length) {
                        for (var _d = 0, declarations_2 = declarations; _d < declarations_2.length; _d++) {
                            var id = declarations_2[_d].id;
                            addConstantNames(additionalConstantNames, id);
                        }
                        if (parent.parentPath.isBlockStatement()) {
                            var newPaths = parent.insertBefore(types.variableDeclaration("var", declarations));
                            if (isNewBabel) {
                                parent.scope.registerDeclaration(newPaths[0]);
                            }
                        }
                        else {
                            parent.replaceWith(blockStatement([types.variableDeclaration("var", declarations), parent.node]));
                            if (parent.isBlockStatement()) {
                                parent = parent.get("body")[1];
                            }
                        }
                    }
                    if (reusingExisting) {
                        if (types.isVariableDeclaration(reusingExisting.parent) && reusingExisting.parent.declarations.length === 1) {
                            reusingExisting.parentPath.replaceWith(types.emptyStatement());
                        }
                        else {
                            reusingExisting.remove();
                        }
                    }
                    relocateTail(pluginState, awaitExpression, parent.node, parent, additionalConstantNames, resultIdentifier, undefined, directExpression);
                }
            }
        }
    }
    var rewriteAsyncBlockVisitor = {
        Function: skipNode,
        AwaitExpression: rewriteAwaitPath,
        ForAwaitStatement: rewriteAwaitPath,
        ForOfStatement: function (path) {
            if (path.node.await) { // Support babel versions with .await property on ForOfStatement type
                rewriteAwaitPath.call(this, path);
            }
        },
        CallExpression: function (path) {
            var callee = path.get("callee");
            if (callee.isIdentifier() && callee.node.name === "eval") {
                throw path.buildCodeFrameError("Calling eval from inside an async function is not supported!");
            }
        }
    };
    var unpromisifyVisitor = {
        Function: skipNode,
        ReturnStatement: function (path) {
            var argument = path.get("argument");
            if (argument.node) {
                unpromisify(argument, this);
            }
        }
    };
    function unpromisify(path, pluginState) {
        if (path.isNumericLiteral()) {
            return;
        }
        if (path.isBooleanLiteral()) {
            return;
        }
        if (path.isStringLiteral()) {
            return;
        }
        if (path.isNullLiteral()) {
            return;
        }
        if (path.isIdentifier() && path.node.name === "undefined") {
            return;
        }
        if (path.isArrayExpression()) {
            return;
        }
        if (path.isObjectExpression()) {
            return;
        }
        if (path.isBinaryExpression()) {
            return;
        }
        if (path.isUnaryExpression()) {
            return;
        }
        if (path.isUpdateExpression()) {
            return;
        }
        if (path.isCallExpression() && types.isIdentifier(path.node.callee) && path.node.callee._helperName) {
            switch (path.node.callee._helperName) {
                case "_await":
                case "_call": {
                    var args = path.get("arguments");
                    if (args.length > 2) {
                        var firstArg = args[1];
                        if (firstArg.isFunctionExpression()) {
                            firstArg.traverse(unpromisifyVisitor, pluginState);
                        }
                        else if (firstArg.isIdentifier()) {
                            var binding = firstArg.scope.getBinding(firstArg.node.name);
                            if (binding && binding.path.isVariableDeclarator()) {
                                binding.path.get("init").traverse(unpromisifyVisitor, pluginState);
                            }
                        }
                    }
                    break;
                }
                case "_awaitIgnored":
                case "_callIgnored":
                    break;
            }
            return;
        }
        if (path.isLogicalExpression()) {
            unpromisify(path.get("left"), pluginState);
            unpromisify(path.get("right"), pluginState);
            return;
        }
        if (path.isConditionalExpression()) {
            unpromisify(path.get("consequent"), pluginState);
            unpromisify(path.get("alternate"), pluginState);
            return;
        }
        if (path.isSequenceExpression()) {
            var expressions = path.get("expressions");
            if (expressions.length) {
                unpromisify(expressions[expressions.length - 1], pluginState);
            }
            return;
        }
        path.replaceWith(logicalNot(logicalNot(path.node, pluginState.opts.minify), pluginState.opts.minify));
    }
    function rewriteAsyncBlock(pluginState, path, additionalConstantNames, exitIdentifier, unpromisify) {
        path.traverse(rewriteAsyncBlockVisitor, { pluginState: pluginState, path: path, additionalConstantNames: additionalConstantNames, exitIdentifier: exitIdentifier });
        if (unpromisify) {
            // Rewrite values that potentially could be promises to booleans so that they aren't awaited
            path.traverse(unpromisifyVisitor, pluginState);
        }
    }
    var getHelperDependenciesVisitor = {
        Identifier: function (path) {
            if (identifierSearchesScope(path) && path.hub.file.scope.getBinding(path.node.name) && this.dependencies.indexOf(path.node.name) === -1) {
                this.dependencies.push(path.node.name);
            }
        }
    };
    function getHelperDependencies(path) {
        var state = { dependencies: [] };
        path.traverse(getHelperDependenciesVisitor, state);
        return state.dependencies;
    }
    var usesIdentifierVisitor = {
        Identifier: function (path) {
            if (path.node.name === this.name) {
                this.found = true;
                path.stop();
            }
        }
    };
    function usesIdentifier(path, name) {
        var state = { name: name, found: false };
        path.traverse(usesIdentifierVisitor, state);
        return state.found;
    }
    function helperReference(state, path, name) {
        var file = path.scope.hub.file;
        var result = file.declarations[name];
        if (!result) {
            result = file.declarations[name] = usesIdentifier(file.path, name) ? file.path.scope.generateUidIdentifier(name) : types.identifier(name);
            result._helperName = name;
            if (state.opts.externalHelpers) {
                file.path.unshiftContainer("body", types.importDeclaration([types.importSpecifier(result, types.identifier(name))], types.stringLiteral("babel-plugin-transform-async-to-promises/helpers")));
            }
            else {
                if (!helpers) {
                    // Read helpers from ./helpers.js
                    var newHelpers_1 = {};
                    var helperCode = fs_1.readFileSync(path_1.join(__dirname, "helpers.js")).toString();
                    var helperAst = require("babylon").parse(helperCode, { sourceType: "module" });
                    transformFromAst(helperAst, helperCode, { babelrc: false, plugins: [{ visitor: {
                                    ExportNamedDeclaration: function (path) {
                                        var declaration = path.get("declaration");
                                        if (declaration.isFunctionDeclaration()) {
                                            newHelpers_1[declaration.node.id.name] = {
                                                value: declaration.node,
                                                dependencies: getHelperDependencies(declaration)
                                            };
                                            return;
                                        }
                                        if (declaration.isVariableDeclaration() && declaration.node.declarations.length === 1) {
                                            var declaratorId = declaration.node.declarations[0].id;
                                            if (types.isIdentifier(declaratorId)) {
                                                newHelpers_1[declaratorId.name] = {
                                                    value: declaration.node,
                                                    dependencies: getHelperDependencies(declaration)
                                                };
                                                return;
                                            }
                                        }
                                        throw path.buildCodeFrameError("Expected a named export from built-in helper!");
                                    }
                                } }] });
                    helpers = newHelpers_1;
                }
                var helper = helpers[name];
                for (var _i = 0, _a = helper.dependencies; _i < _a.length; _i++) {
                    var dependency = _a[_i];
                    helperReference(state, path, dependency);
                }
                var value = types.cloneDeep(helper.value);
                var traversePath = file.path.get("body")[0];
                if (types.isVariableDeclaration(value) && traversePath.isVariableDeclaration()) {
                    // TODO: Support variable declaration that references another variable declaration (this case doesn't exist yet in our helpers, but may in the future)
                    traversePath.unshiftContainer("declarations", value.declarations[0]);
                    traversePath = file.path.get("body")[0].get("declarations")[0];
                }
                else {
                    file.path.unshiftContainer("body", value);
                    traversePath = file.path.get("body")[0];
                }
                traversePath.traverse({
                    Identifier: function (path) {
                        var name = path.node.name;
                        if (Object.hasOwnProperty.call(helpers, name)) {
                            path.replaceWith(file.declarations[name]);
                        }
                    }
                });
            }
        }
        return result;
    }
    function isAsyncCallExpression(path) {
        if (types.isIdentifier(path.node.callee)) {
            switch (path.node.callee._helperName) {
                case "_await":
                case "_call":
                    return path.node.arguments.length < 3;
            }
        }
        return false;
    }
    function invokeTypeOfExpression(path) {
        if (path.isCallExpression() && types.isIdentifier(path.node.callee)) {
            var helperName = path.node.callee._helperName;
            switch (helperName) {
                case "_invoke":
                case "_invokeIgnored":
                    return helperName;
            }
        }
    }
    function isAsyncFunctionExpression(path) {
        if (path.isFunction() && (path.node.async || path.node._async)) {
            return true;
        }
        if (path.isCallExpression() && types.isIdentifier(path.node.callee) && path.node.callee._helperName === "_async") {
            return true;
        }
        return false;
    }
    function isAsyncFunctionIdentifier(path) {
        if (path.isIdentifier()) {
            var binding = path.scope.getBinding(path.node.name);
            if (binding && binding.constant) {
                var bindingPath = binding.path;
                if (bindingPath.isVariableDeclarator()) {
                    var initPath = bindingPath.get("init");
                    if (initPath.node && isAsyncFunctionExpression(initPath)) {
                        return true;
                    }
                }
                else if (bindingPath.isFunctionDeclaration()) {
                    if (isAsyncFunctionExpression(bindingPath)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    function isEvalOrArguments(path) {
        return path.isIdentifier() && (path.node.name === "arguments" || path.node.name === "eval");
    }
    function identifierSearchesScope(path) {
        if (path.node.name === "undefined") {
            return false;
        }
        if (path.node._helperName) {
            return false;
        }
        var parent = path.parentPath;
        if (parent.isVariableDeclarator() && parent.get("id") === path) {
            return false;
        }
        if (parent.isMemberExpression() && !parent.node.computed && parent.get("property") === path) {
            return false;
        }
        if (parent.isLabeledStatement() && parent.get("label") === path) {
            return false;
        }
        return true;
    }
    function canThrow() {
        this.canThrow = true;
    }
    var checkForErrorsAndRewriteReturnsVisitor = {
        Function: skipNode,
        ThrowStatement: canThrow,
        ForInStatement: canThrow,
        ForOfStatement: canThrow,
        WithStatement: canThrow,
        MemberExpression: canThrow,
        NewExpression: canThrow,
        TryStatement: function (path) {
            if (path.get("handler")) {
                path.get("block").skip();
            }
        },
        CallExpression: function (path) {
            if (!isAsyncCallExpression(path)) {
                if (invokeTypeOfExpression(path) === "_invoke") {
                    var args = path.get("arguments");
                    if (checkForErrorsAndRewriteReturns(args[0], this.plugin)) {
                        this.canThrow = true;
                    }
                    if (args[1]) {
                        args[1].traverse(checkForErrorsAndRewriteReturnsVisitor, this);
                    }
                }
                else {
                    var callee = path.get("callee");
                    if (!isAsyncFunctionIdentifier(callee)) {
                        this.canThrow = true;
                    }
                }
            }
        },
        UpdateExpression: function (path) {
            if (isEvalOrArguments(path.get("argument"))) {
                this.canThrow = true;
            }
        },
        UnaryExpression: function (path) {
            switch (path.node.operator) {
                case "delete":
                    // Not strictly true that all delete expressions can potentially throw, but better to be cautious
                    this.canThrow = true;
                    break;
            }
        },
        BinaryExpression: function (path) {
            switch (path.node.operator) {
                case "instanceof":
                case "in":
                    this.canThrow = true;
                    break;
            }
        },
        Identifier: function (path) {
            if (identifierSearchesScope(path) && !path.scope.getBinding(path.node.name)) {
                this.canThrow = true;
            }
        },
        AssignmentExpression: function (path) {
            if (isEvalOrArguments(path.get("left"))) {
                this.canThrow = true;
            }
        },
        ReturnStatement: function (path) {
            if (this.rewriteReturns) {
                var argument = path.get("argument");
                if (!argument.node || !((argument.isCallExpression() && isAsyncCallExpression(argument)) || invokeTypeOfExpression(argument) === "_invoke" || (argument.isCallExpression() && isAsyncFunctionIdentifier(argument.get("callee"))))) {
                    argument.replaceWith(types.callExpression(helperReference(this.plugin, path, "_await"), argument.node ? [argument.node] : []));
                }
            }
        }
    };
    function checkForErrorsAndRewriteReturns(path, plugin, rewriteReturns) {
        if (rewriteReturns === void 0) { rewriteReturns = false; }
        var state = { rewriteReturns: rewriteReturns, plugin: plugin, canThrow: false };
        path.traverse(checkForErrorsAndRewriteReturnsVisitor, state);
        return state.canThrow;
    }
    var rewriteTopLevelReturnsVisitor = {
        Function: skipNode,
        ReturnStatement: function (path) {
            var argument = path.get("argument");
            if (argument.isCallExpression()) {
                var callArgs = argument.node.arguments;
                switch (callArgs.length) {
                    case 3:
                    case 2: {
                        var secondArgument = callArgs[1];
                        if (!types.isUnaryExpression(secondArgument) || secondArgument.operator !== "void") {
                            break;
                        }
                        // fallthrough
                    }
                    case 1:
                        if (types.isIdentifier(argument.node.callee)) {
                            var firstArgument = callArgs[0];
                            if (types.isExpression(firstArgument)) {
                                switch (argument.node.callee._helperName) {
                                    case "_await":
                                        argument.replaceWith(firstArgument);
                                        break;
                                    case "_call":
                                        argument.replaceWith(types.callExpression(firstArgument, []));
                                        break;
                                }
                            }
                        }
                        break;
                }
            }
        }
    };
    return {
        manipulateOptions: function (options, parserOptions) {
            parserOptions.plugins.push("asyncGenerators");
        },
        visitor: {
            FunctionDeclaration: function (path) {
                var node = path.node;
                if (node.async) {
                    var expression = types.functionExpression(undefined, node.params, node.body, node.generator, node.async);
                    var declarators = [types.variableDeclarator(node.id, expression)];
                    var targetPath = void 0;
                    if (path.parentPath.isExportDeclaration()) {
                        path.replaceWith(types.variableDeclaration("const", declarators));
                        targetPath = path.parentPath;
                    }
                    else {
                        path.replaceWith(types.variableDeclaration("var", declarators));
                        targetPath = path;
                    }
                    for (var _i = 0, _a = targetPath.getAllPrevSiblings().reverse(); _i < _a.length; _i++) {
                        var sibling = _a[_i];
                        if (!sibling.isFunctionDeclaration()) {
                            var newNode = targetPath.node;
                            targetPath.remove();
                            sibling.insertBefore(newNode);
                            return;
                        }
                    }
                }
            },
            ArrowFunctionExpression: function (path) {
                var node = path.node;
                if (node.async) {
                    rewriteThisExpressions(path, path.getFunctionParent());
                    var body = types.isBlockStatement(path.node.body) ? path.node.body : blockStatement([types.returnStatement(path.node.body)]);
                    path.replaceWith(types.functionExpression(undefined, node.params, body, false, node.async));
                }
            },
            FunctionExpression: function (path) {
                if (path.node.async) {
                    rewriteThisArgumentsAndHoistFunctions(path, path);
                    rewriteAsyncBlock(this, path, []);
                    var inlineAsync = this.opts.inlineAsync;
                    var bodyPath = path.get("body");
                    var canThrow_1 = checkForErrorsAndRewriteReturns(bodyPath, this, inlineAsync);
                    if (inlineAsync && !pathsReturnOrThrowCurrentNodes(bodyPath).all) {
                        path.node.body.body.push(types.returnStatement());
                    }
                    if (canThrow_1) {
                        if (inlineAsync) {
                            path.replaceWith(types.functionExpression(undefined, path.node.params, blockStatement(types.tryStatement(bodyPath.node, types.catchClause(types.identifier("e"), blockStatement([types.returnStatement(types.callExpression(types.memberExpression(types.identifier("Promise"), types.identifier("reject")), [types.identifier("e")]))]))))));
                        }
                        else {
                            bodyPath.traverse(rewriteTopLevelReturnsVisitor);
                            path.replaceWith(types.callExpression(helperReference(this, path, "_async"), [
                                types.functionExpression(undefined, path.node.params, bodyPath.node)
                            ]));
                        }
                    }
                    else {
                        if (!inlineAsync) {
                            checkForErrorsAndRewriteReturns(bodyPath, this, true);
                        }
                        path.replaceWith(types.functionExpression(undefined, path.node.params, bodyPath.node));
                    }
                    path.node._async = true;
                }
            },
            ClassMethod: function (path) {
                if (path.node.async) {
                    if (path.node.kind === "method") {
                        var body = path.get("body");
                        body.replaceWith(types.blockStatement([types.returnStatement(types.callExpression(helperReference(this, path, "_call"), [types.functionExpression(undefined, [], body.node)]))]));
                        var returnPath = body.get("body")[0];
                        if (returnPath.isReturnStatement()) {
                            var returnArgument = returnPath.get("argument");
                            if (returnArgument.isCallExpression()) {
                                var callArgument = returnArgument.get("arguments")[0];
                                rewriteThisArgumentsAndHoistFunctions(callArgument, path);
                                rewriteAsyncBlock(this, callArgument, []);
                                path.replaceWith(types.classMethod(path.node.kind, path.node.key, path.node.params, path.node.body, path.node.computed, path.node.static));
                            }
                            else {
                                throw returnArgument.buildCodeFrameError("Expected a call expression!");
                            }
                        }
                        else {
                            throw returnPath.buildCodeFrameError("Expected a return statement!");
                        }
                    }
                }
            },
            ObjectMethod: function (path) {
                if (path.node.async) {
                    if (path.node.kind === "method") {
                        path.replaceWith(types.objectProperty(path.node.key, types.functionExpression(undefined, path.node.params, path.node.body, path.node.generator, path.node.async), path.node.computed, false, path.node.decorators));
                    }
                }
            }
        }
    };
}
exports["default"] = default_1;
module.exports = exports["default"];
//# sourceMappingURL=async-to-promises.js.map